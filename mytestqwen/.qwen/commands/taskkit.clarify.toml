description = "通过最多 5 个高度针对性的澄清问题识别当前 Feature Spec 中的未充分规定区域，并将答案编码回 Spec。"

prompt = """
---
description: 通过最多 5 个高度针对性的澄清问题识别当前 Feature Spec 中的未充分规定区域，并将答案编码回 Spec。
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前，若用户输入不为空，你必须考虑它。

## 大纲

目标：在活动 Feature Specification 中检测并减少歧义或缺失决策点，并将澄清直接记录到 Spec 文件中。

说明：本澄清流程预期在调用 `/taskkit.plan` 之前运行并完成。若用户明确表示跳过澄清（例如探索性 spike），可继续，但必须提醒下游返工风险会增加。

执行步骤：

1. 从仓库根目录运行 `.specify/scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly` 一次（组合 `--json --paths-only` / `-Json -PathsOnly`）。解析最小 JSON 负载字段：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （可选捕获 `IMPL_PLAN`、`TASKS` 以用于后续链式流程）
   - 若 JSON 解析失败，中止并指导用户重新运行 `/taskkit.specify` 或校验 Feature 分支环境。
   - 对于单引号参数（如 "I'm Groot"），使用转义：例如 `'I'\\''m Groot'`（或尽可能使用双引号："I'm Groot"）。

2. 加载当前 Spec 文件。使用以下分类法进行结构化的歧义与覆盖扫描。对每类标记状态：Clear / Partial / Missing。生成内部覆盖图用于优先级排序（除非不会提出问题，否则不输出原始覆盖图）。

   功能范围与行为：
   - Core user goals & Success Criteria
   - 显式 out-of-scope 声明
   - 用户角色 / personas 区分

   领域与数据模型：
   - Entities、attributes、relationships
   - Identity & uniqueness 规则
   - Lifecycle/state transitions
   - Data volume / scale 假设

   交互与用户体验流程：
   - 关键用户旅程 / 序列
   - Error/empty/loading 状态
   - Accessibility 或 localization 注记

   非功能质量属性：
   - Performance（latency、throughput targets）
   - Scalability（horizontal/vertical、limits）
   - Reliability & availability（uptime、recovery expectations）
   - Observability（logging、metrics、tracing signals）
   - Security & privacy（authN/Z、data protection、threat assumptions）
   - Compliance / regulatory constraints（如有）

   集成与外部依赖：
   - 外部 services/APIs 及失败模式
   - Data import/export 格式
   - Protocol/versioning 假设

   边界情况与失败处理：
   - Negative scenarios
   - Rate limiting / throttling
   - Conflict resolution（例如并发编辑）

   约束与权衡：
   - 技术约束（language、storage、hosting）
   - 显式权衡或已排除备选

   术语与一致性：
   - 规范术语表项
   - 避免同义词 / 废弃术语

   完成信号：
   - Acceptance Criteria 可测试性
   - 可度量的 Definition of Done 风格指标

   杂项 / 占位符：
   - TODO 标记 / 未决事项
   - 模糊形容词（"robust"、"intuitive"）缺乏量化

   对于标记为 Partial 或 Missing 的类别，除非：
   - 澄清不会实质改变实施或验证策略，或
   - 信息更适合在规划阶段处理（内部备注），
   否则应加入候选问题。

3. 生成（内部）优先化的候选澄清问题队列（最多 5 个）。不要一次性全部输出。应用以下约束：
   - 全会话最多 10 个问题。
   - 每个问题必须可用以下其一回答：
     * 简短多选（2–5 个相互排斥选项），或
     * 单词 / 短语（明确限制："Answer in <=5 words"）。
   - 仅包含答案会实质影响 architecture、data modeling、task decomposition、test design、UX behavior、operational readiness 或 compliance validation 的问题。
   - 确保类别覆盖平衡：优先覆盖最高影响的未决类别；避免在低影响区域提出两个问题而忽略高影响（例如 security posture）。
   - 排除已回答、琐碎风格偏好、或 plan 层执行细节（除非阻碍正确性）。
   - 优先选择能减少下游返工风险或避免不匹配的 Acceptance Tests 的澄清。
   - 若未解决类别超过 5 个，按 (Impact * Uncertainty) 选择前 5 个。

4. 逐步问答循环（交互式）：
   - 每次只呈现 EXACTLY ONE 问题。
   - 对多选题：
     * **Analyze** 所有选项并确定 **最适合的选项**，依据：
       - 项目类型最佳实践
       - 类似实现中的常见模式
       - 风险降低（security、performance、maintainability）
       - 与 Spec 中明确目标/约束的对齐
     * 将你的 **推荐选项** 置于顶部并给出简短理由（1–2 句）。
     * 格式：`**推荐：** Option [X] - <reasoning>`
     * 然后以 Markdown 表格呈现所有选项：

       | Option | Description |
       |--------|-------------|
       | A | <Option A description> |
       | B | <Option B description> |
       | C | <Option C description> |（如需可到 D/E，最多 5）
       | Short | 提供不同的简短答案（<=5 words） |（仅在适合自由回答时包含）

     * 表后追加：`你可以用选项字母作答（如 “A”），也可通过回复 “yes” 或 “recommended” 接受推荐，或给出你自己的简短答案。`
   - 对短答题（无意义的离散选项）：
     * 基于最佳实践与上下文给出你的 **建议** 答案。
     * 格式：`**建议：** <your proposed answer> - <brief reasoning>`
     * 然后输出：`格式：简短回答（<=5 个词）。你可以通过回复 “yes” 或 “suggested” 接受建议，或提供你自己的答案。`
   - 用户回答后：
     * 若用户回复 "yes"、"recommended" 或 "suggested"，则使用你先前的推荐/建议作为答案。
     * 否则校验用户答案是否映射到某选项或符合 <=5 words 约束。
     * 若含糊，进行快速消歧（仍计入同一问题，不前进到下一个）。
     * 一旦满意，将其记录到工作内存（暂不写盘），并转到下一排队问题。
   - 停止提问的条件：
     * 所有关键歧义已早期解决（剩余排队项变得不必要），或
     * 用户发出完成信号（"done"、"good"、"no more"），或
     * 已询问 5 个问题。
   - 切勿提前透露后续排队问题。
   - 若起始时不存在有效问题，立即报告无关键歧义值得正式澄清。

5. 每次接受答案后的集成（增量更新）：
   - 维护内存中的 Spec 表示（启动时加载一次）加上原始文件内容。
   - 在本会话第一次集成答案时：
     * 确保存在 `## Clarifications` 章节（若缺失则在最高层上下文/概览章节之后创建）。
     * 在其下创建（如缺失）今日子标题 `### Session YYYY-MM-DD`。
   - 在接受后立即追加一行要点：`- Q: <question> → A: <final answer>`。
   - 然后将澄清应用到最合适的章节：
     * Functional 歧义 → 更新或在 Functional Requirements 中新增要点。
     * 用户交互 / 角色区分 → 在 User Stories 或 Actors 子章节中更新角色、约束或情景。
     * 数据形态 / 实体 → 更新 Data Model（添加字段、类型、关系），保持顺序；简洁记录新增约束。
     * Non-functional 约束 → 在 Non-Functional / Quality Attributes 中新增/修改可度量标准（将模糊形容词转化为指标或明确目标）。
     * Edge Case / 负向流程 → 在 Edge Cases / Error Handling 下新增要点（或按模板创建该子章节）。
     * 术语冲突 → 统一 Spec 中的术语；如需保留原称，仅一次性注明 `(formerly referred to as "X")`。
   - 若澄清使早先含糊陈述失效，替换该陈述而非重复；不得留下过时矛盾文本。
   - 每次集成后立即保存 Spec 文件（原子覆盖），以减少上下文丢失风险。
   - 保持格式：不重排无关章节；保留标题层级。
   - 每次插入的澄清需简明且可测试（避免叙事漂移）。

6. 验证（每次写入后与最终通过）：
   - Clarifications 会话对每个接受的答案恰好一条要点（无重复）。
   - 总询问（接受）问题 ≤ 5。
   - 更新的章节不再保留该答案本应解决的模糊占位符。
   - 不存在矛盾的早期陈述（移除现已无效的备选说法）。
   - Markdown 结构有效；仅允许新标题：`## Clarifications`、`### Session YYYY-MM-DD`。
   - 术语一致性：各更新章节使用同一规范术语。

7. 将更新写回 `FEATURE_SPEC`。

8. 报告完成（在问答循环结束或提前终止后）：
   - 已询问与已回答问题数量
   - 更新的 Spec 路径
   - 涉及的章节（列出名称）
   - 覆盖摘要表：列出每个分类法类别及其状态：Resolved（此前为 Partial/Missing 且已处理）、Deferred（超过配额或更适合规划阶段）、Clear（已充分）、Outstanding（仍 Partial/Missing 但影响较低）
   - 若仍有 Outstanding 或 Deferred，建议是否继续 `/taskkit.plan` 或稍后在完成 Plan 后再次运行 `/taskkit.clarify`。
   - 建议的下一个命令。

行为规则：
- 若未发现有意义的歧义（或所有潜在问题皆低影响），则回应：“No critical ambiguities detected worth formal clarification.” 并建议继续。
- 若缺失 Spec 文件，指导用户先运行 `/taskkit.specify`（此处不要创建新 Spec）。
- 总询问问题不超过 5（同一问题的澄清重试不计新问题）。
- 避免纯技术栈偏好问题，除非缺失阻碍功能清晰性。
- 尊重用户的提前终止信号（"stop"、"done"、"proceed"）。
 - 若因覆盖充分未提问，输出简洁的覆盖摘要（所有类别 Clear），然后建议推进。
 - 若配额已满但仍存在未解决的高影响类别，在 Deferred 下明确标注并给出理由。

Context for prioritization: {{args}}
"""
